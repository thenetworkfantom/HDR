from slips_files.common.imports import *
import json
import sys
import ipaddress
import time
import threading
from multiprocessing import Queue

class ARP(Module, multiprocessing.Process):

    name = 'ARP'
    description = 'Detect arp attacks'
    authors = ['HackTheHeck']
    def init(self):
        self.c1 = self.db.subscribe('new_arp')
        self.c2 = self.db.subscribe('tw_closed')
        self.channels = {
            'new_arp': self.c1,
            'tw_closed': self.c2,
        }
        self.read_configuration()

        self.cache_arp_requests = {}

        self.arp_scan_threshold = 5
        self.delete_arp_periodically = False
        self.arp_ts = 0
        self.period_before_deleting = 0
        if (
            self.delete_zeek_files
            and not self.store_zeek_files_copy
        ):
            self.delete_arp_periodically = True

            self.arp_ts = time.time()

            self.period_before_deleting = 3600
        self.timer_thread_arp_scan = threading.Thread(
                                target=self.wait_for_arp_scans,
                                daemon=True
        )
        self.pending_arp_scan_evidence = Queue()
        self.alerted_once_arp_scan = False

        self.time_to_wait = 10


    def read_configuration(self):
        conf = ConfigParser()
        self.home_network = conf.home_network_ranges
        self.delete_zeek_files = conf.delete_zeek_files()
        self.store_zeek_files_copy = conf.store_zeek_files_copy()

    def wait_for_arp_scans(self):
        """
        This thread waits for 10s then checks if more
        arp scans happened to reduce the number of alerts
        """

        scans_ctr = 0
        while True:
            try:
                evidence: dict = self.pending_arp_scan_evidence.get(timeout=0.5)
            except Exception:

                time.sleep(5)
                continue

            (ts, profileid, twid, uids, conn_count) = evidence


            time.sleep(self.time_to_wait)

            while True:
                try:
                    new_evidence = self.pending_arp_scan_evidence.get(timeout=0.5)
                except Exception:

                    break

                (ts2, profileid2, twid2, uids2, conn_count2) = new_evidence
                if (
                    profileid == profileid2
                    and twid == twid2
                ):

                    ts = ts2
                    uids += uids2
                    conn_count = conn_count2
                else:

                    scans_ctr += 1
                    self.pending_arp_scan_evidence.put(new_evidence)
                    if scans_ctr == 3:
                        scans_ctr = 0
                        break

            self.set_evidence_arp_scan(
                ts,
                profileid,
                twid,
                uids,
                conn_count
            )



    def check_arp_scan(
        self, profileid, twid, daddr, uid, ts, dst_mac, src_mac, operation, dst_hw, src_hw
    ):
        """
        Check if the profile is doing an arp scan
        If IP X sends arp requests to 3 or more different IPs within 30 seconds, then this IP X is doing arp scan
        The key profileid_twid is used to group requests from the same saddr
        arp flows don't have uids, the uids received are randomly generated by slips
        """


        if 'request' not in operation or '00:00:00:00:00:00' not in dst_hw:
            return False

        def get_uids():
            """
            get the uids causing this evidence
            """
            res = []
            for daddr, daddr_info in cached_requests.items():
                for uid in daddr_info['uids']:
                    res.append(uid)
            return res


        saddr = profileid.split('_')[1]


        if self.db.get_gateway_ip() == saddr:
            return False


        if saddr == '0.0.0.0':
            return False

        daddr_info = {
            daddr: {
                'uids': [uid],
                'ts': ts
            }
        }
        try:

            cached_requests = self.cache_arp_requests[f'{profileid}_{twid}']

            if daddr in cached_requests:
                cached_requests[daddr]['uids'].append(uid)
                cached_requests[daddr]['ts'] = ts
                self.cache_arp_requests[f'{profileid}_{twid}'] = cached_requests
            else:
                cached_requests.update(
                    daddr_info
                )
        except KeyError:

            self.cache_arp_requests[f'{profileid}_{twid}'] = daddr_info

            return True


        daddrs = list(cached_requests.keys())


        if len(daddrs) >= self.arp_scan_threshold:

            first_daddr = daddrs[0]
            last_daddr = daddrs[-1]
            starttime = cached_requests[first_daddr]['ts']
            endtime = cached_requests[last_daddr]['ts']

            self.diff = utils.get_time_diff(starttime, endtime)


            if self.diff <= 30.00:
                conn_count = len(daddrs)
                uids = get_uids()

                if not self.alerted_once_arp_scan:
                    self.alerted_once_arp_scan = True
                    self.set_evidence_arp_scan(ts, profileid, twid, uids, conn_count)
                else:

                    self.pending_arp_scan_evidence.put((ts, profileid, twid, uids, conn_count))

                return True
        return False

    def set_evidence_arp_scan(self, ts, profileid, twid, uids, conn_count):
        confidence = 0.8
        threat_level = 'low'
        description = (
            f'performing an arp scan. Confidence {confidence}.'
        )
        evidence_type = 'ARPScan'
        category = 'Recon.Scanning'
        attacker_direction = 'srcip'
        source_target_tag = 'Recon'
        attacker = profileid.split('_')[1]
        self.db.setEvidence(evidence_type, attacker_direction, attacker, threat_level, confidence, description,
                                 ts, category, source_target_tag=source_target_tag, conn_count=conn_count,
                                 profileid=profileid, twid=twid, uid=uids)
        try:
            self.cache_arp_requests.pop(f'{profileid}_{twid}')
        except KeyError:
            pass

    def check_dstip_outside_localnet(
        self, profileid, twid, daddr, uid, saddr, ts
    ):
        """Function to setEvidence when daddr is outside the local network"""

        if '0.0.0.0' in saddr or '0.0.0.0' in daddr:

            return False

        daddr_as_obj = ipaddress.IPv4Address(daddr)
        if daddr_as_obj.is_multicast or daddr_as_obj.is_link_local:

            return False

        for network in self.home_network:
            if daddr_as_obj in network:

                return False


        local_net = saddr.split('.')[0]
        if not daddr.startswith(local_net):

            confidence = 0.6
            threat_level = 'low'
            ip_identification = self.db.get_ip_identification(daddr)
            description = f'{saddr} sending ARP packet to a destination address outside of local network: {daddr}. {ip_identification}'
            evidence_type = 'arp-outside-localnet'
            category = 'Anomaly.Behaviour'
            attacker_direction = 'srcip'
            attacker = profileid.split('_')[1]
            self.db.setEvidence(evidence_type, attacker_direction, attacker, threat_level, confidence,
                                     description, ts, category, profileid=profileid, twid=twid, uid=uid, victim=daddr)
            return True

    def detect_unsolicited_arp(
        self, profileid, twid, uid, ts, dst_mac, src_mac, dst_hw, src_hw
    ):
        """Unsolicited arp is used to update the neighbours' arp caches but can also be used in arp spoofing"""
        if (
            dst_mac == 'ff:ff:ff:ff:ff:ff'
            and dst_hw == 'ff:ff:ff:ff:ff:ff'
            and src_mac != '00:00:00:00:00:00'
            and src_hw != '00:00:00:00:00:00'
        ):

            confidence = 0.8
            threat_level = 'info'
            description = 'broadcasting unsolicited ARP'
            evidence_type = 'UnsolicitedARP'

            category = 'Information'
            attacker_direction = 'srcip'
            source_target_tag = 'Recon'   # srcip description
            attacker = profileid.split('_')[1]
            self.db.setEvidence(evidence_type, attacker_direction, attacker, threat_level, confidence,
                                     description, ts, category, source_target_tag=source_target_tag,
                                     profileid=profileid, twid=twid, uid=uid)
            return True

    def detect_MITM_ARP_attack(self, profileid, twid, uid, saddr, ts, src_mac):
        """Detects when a MAC with IP A, is trying to tell others that now that MAC is also for IP B (arp cache attack)"""

        original_IP = self.db.get_ip_of_mac(src_mac)
        if original_IP is None:
            return


        original_IP = json.loads(original_IP)[0]


        if saddr != original_IP:

            confidence = 0.2
            threat_level = 'critical'
            evidence_type = 'MITM-arp-attack'

            category = 'Recon'
            attacker_direction = 'srcip'
            source_target_tag = 'MITM'
            attacker = profileid.split('_')[1]

            gateway_ip = self.db.get_gateway_ip()
            gateway_MAC = self.db.get_gateway_mac()

            if saddr == gateway_ip:
                saddr = f'The gateway {saddr}'

            if src_mac == gateway_MAC:
                src_mac = f'of the gateway {src_mac}'

            original_IP = f'IP {original_IP}'
            if original_IP == gateway_ip:
                original_IP = f'the gateway IP {original_IP}'

            description = f'{saddr} performing a MITM ARP attack. The MAC {src_mac}, ' \
                          f'now belonging to {saddr}, was seen before for {original_IP}.'

            self.db.setEvidence(evidence_type, attacker_direction, attacker, threat_level, confidence,
                                     description, ts, category, source_target_tag=source_target_tag,
                                     profileid=profileid, twid=twid, uid=uid, victim=original_IP)
            return True


    def check_if_gratutitous_ARP(
            self, saddr, daddr, src_mac, dst_mac, src_hw, dst_hw, operation
        ):
        """
        Check if an ARP packet is gratuitous

        # The Gratuitous arp is sent as a broadcast, as a way for a node to announce or update
        # its IP to MAC mapping to the entire network.
        #  Gratuitous ARP shouldn't be marked as an arp scan
        # Check https://www.practicalnetworking.net/series/arp/gratuitous-arp/
        # dst_mac is the real MAC used to deliver the packet
        # src_mac is the real MAC used to deliver the packet
        # dst_hw is the MAC in the headers of the ARP packet
        # src_hw is the MAC in the headers of the ARP packet
        # saddr is the IP in the headers of the ARP packet
        # daddr is the IP in the headers of the ARP packet

        # Gratuitous ARP can be used for (1) Updating ARP Mapping, (2) Announcing a Nodeâ€™s Existence,
        (3) Redundancy, (4) MITM. Which is similar to an 'unrequested' load balancing
        # The saddr and daddr are the ones being avertised. The supposed purpose of the Gratuitous ARP
        """

        is_gratuitous = False
        if 'reply' in operation and dst_hw in [ 'ff:ff:ff:ff:ff:ff', '00:00:00:00:00:00']:
            is_gratuitous = True
        return is_gratuitous

    def pre_main(self):
        """ runs once before the main() is executed in a loop"""
        utils.drop_root_privs()
        self.timer_thread_arp_scan.start()

    def main(self):
        """main loop function"""

        if (
            self.delete_arp_periodically
            and time.time()
            >= self.arp_ts + self.period_before_deleting
        ):

            open('zeek_files/arp.log', 'w').close()

            self.arp_ts = time.time()

        if msg := self.get_msg('new_arp'):
            flow_details = json.loads(msg['data'])
            profileid = flow_details['profileid']
            twid = flow_details['twid']
            flow: dict = flow_details['flow']
            ts = flow['starttime']
            daddr = flow['daddr']
            saddr = flow['saddr']
            dst_mac = flow['dmac']
            src_mac = flow['smac']
            dst_hw = flow['dst_hw']
            src_hw = flow['src_hw']
            operation = flow['operation']

            uid = flow['uid']

            if self.check_if_gratutitous_ARP(
                saddr, daddr, src_mac, dst_mac, src_hw, dst_hw, operation
            ):
                self.detect_MITM_ARP_attack(
                    profileid, twid, uid, saddr, ts, src_mac
                )
            else:
                self.check_arp_scan(
                    profileid, twid, daddr, uid, ts, dst_mac, src_mac, operation, dst_hw, src_hw
                )

            if 'request' in operation:
                self.check_dstip_outside_localnet(
                    profileid, twid, daddr, uid, saddr, ts
                )
            elif 'reply' in operation:
                self.detect_unsolicited_arp(
                    profileid,
                    twid,
                    uid,
                    ts,
                    dst_mac,
                    src_mac,
                    dst_hw,
                    src_hw,
                )
        if msg := self.get_msg('tw_closed'):
            profileid_tw = msg['data']
            cache_copy = self.cache_arp_requests.copy()
            for key in cache_copy:
                if profileid_tw in key:
                    self.cache_arp_requests.pop(key)
