
















from pathlib import Path
from re import split
import signal
import sys
import os
from slips_files.common.abstracts import Core
from datetime import datetime
from watchdog.observers import Observer
from slips_files.core.helpers.filemonitor import FileEventHandler
from slips_files.common.imports import *
import time
import json
import threading
import subprocess


class InputProcess(Core):
    """ A class process to run the process of the flows """

    name = 'Input'
    def init(
            self,
            profiler_queue=None,
            input_type=None,
            input_information=None,
            cli_packet_filter= None,
            zeek_or_bro=None,
            zeek_dir=None,
            line_type=None,
    ):
        self.input_type = input_type
        self.profiler_queue = profiler_queue


        self.line_type = line_type

        self.given_path = input_information
        self.zeek_dir = zeek_dir
        self.zeek_or_bro = zeek_or_bro
        self.read_lines_delay = 0

        self.packet_filter = False
        if cli_packet_filter:
            self.packet_filter = f"'{cli_packet_filter}'"

        self.read_configuration()
        self.event_observer = None

        self.testing = False

        self.lines = 0

        self.ignored_files = {
            'capture_loss',
            'loaded_scripts',
            'packet_filter',
            'stats',
            'ocsp',
            'reporter',
            'x509',
            'pe',
            'mqtt_publish',
            'mqtt_subscribe',
            'mqtt_connect',
            'analyzer',
            'ntp',
            'radiuss',
            'sip',
            'syslog'
        }

        self.remover_thread = threading.Thread(
            target=self.remove_old_zeek_files, daemon=True
        )
        self.open_file_handlers = {}
        self.c1 = self.db.subscribe('remove_old_files')
        self.channels = {'remove_old_files': self.c1}
        self.timeout = None

        self.to_be_deleted = []
        self.zeek_thread = threading.Thread(
            target=self.run_zeek,
            daemon=True
        )

    def read_configuration(self):
        conf = ConfigParser()


        self.packet_filter = self.packet_filter or conf.packet_filter()
        self.tcp_inactivity_timeout = conf.tcp_inactivity_timeout()
        self.enable_rotation = conf.rotation()
        self.rotation_period = conf.rotation_period()
        self.keep_rotated_files_for = conf.keep_rotated_files_for()

    def stop_queues(self):
        """Stops the profiler and output queues"""
        now = utils.convert_format(datetime.now(), utils.alerts_format)
        self.output_queue.put(
            f'02|input|[In] No more input. Stopping input process. Sent {self.lines} lines ({now}).\n'
        )

        self.profiler_queue.put('stop')
        self.output_queue.cancel_join_thread()
        self.profiler_queue.cancel_join_thread()

    def read_nfdump_output(self) -> int:
        """
        A binary file generated by nfcapd can be read by nfdump.
        The task for this function is to send nfdump output line by line to profilerProcess.py for processing
        """
        if not self.nfdump_output:

            self.print('Error reading nfdump output ', 1, 3)
        else:
            total_flows = len(self.nfdump_output.splitlines())
            self.db.set_input_metadata({'total_flows': total_flows})

            for nfdump_line in self.nfdump_output.splitlines():

                nfdump_line.replace(' ', '')
                ts = nfdump_line.split(',')[0]
                if not ts[0].isdigit():


                    continue
                line = {
                    'type': 'nfdump',
                    'data': nfdump_line
                }
                self.profiler_queue.put(line)
                if self.testing: break

        return total_flows

    def check_if_time_to_del_rotated_files(self):
        """
        After a specific period (keep_rotated_files_for), slips deletes all rotated files
        Check if it's time to do so
        """
        if not hasattr(self, 'time_rotated'):
            return False

        now = float(utils.convert_format(datetime.now(), 'unixtimestamp'))
        time_to_delete = now >= self.time_rotated + self.keep_rotated_files_for
        if time_to_delete:



            for file in self.to_be_deleted:
                try:
                    os.remove(file)
                except FileNotFoundError:
                    pass
            self.to_be_deleted = []


    def is_ignored_file(self, filepath: str) -> bool:
        """
        Ignore the files that do not contain data.
        These are the zeek log files that we don't use
        :param filepath: full path to a zeek log file
        """
        filename_without_ext = Path(filepath).stem
        if filename_without_ext in self.ignored_files:
            return True

    def get_file_handle(self, filename):

        try:

            file_handler = self.open_file_handlers[filename]
        except KeyError:

            try:
                file_handler = open(filename, 'r')
                lock = threading.Lock()
                lock.acquire()
                self.open_file_handlers[filename] = file_handler
                lock.release()


            except FileNotFoundError:






                return False
        return file_handler


    def get_ts_from_line(self, zeek_line):
        """
        :param line: can be a json or a json serialized dict
        """
        if self.is_zeek_tabs:

            nline = zeek_line
            nline_list = nline.split('\t') if '\t' in nline else split(r'\s{2,}', nline)
            timestamp = nline_list[0]
        else:
            try:
                nline = json.loads(zeek_line)
            except json.decoder.JSONDecodeError:
                return False, False


            timestamp = nline.get('ts', 0)
        try:
            timestamp = float(timestamp)
        except ValueError:

            return False, False

        return timestamp, nline

    def cache_nxt_line_in_file(self, filename):
        """
        reads 1 line of the given file and stores in queue for sending to the profiler
        """
        file_handle = self.get_file_handle(filename)
        if not file_handle:
            return False


        if filename in self.cache_lines:

            return False


        try:
            zeek_line = file_handle.readline()
        except ValueError:



            return False


        if not zeek_line or zeek_line.startswith('#'):


            return False

        timestamp, nline = self.get_ts_from_line(zeek_line)
        if not timestamp:
            return False


        self.file_time[filename] = timestamp

        self.cache_lines[filename] = {
            'type': filename,
            'data': nline
        }
        return True

    def should_stop_zeek(self):


        if not self.cache_lines:



            diff = utils.get_time_diff(self.last_updated_file_time, datetime.now())
            if diff >= self.bro_timeout:


                return True

    def close_all_handles(self):


        for file, handle in self.open_file_handlers.items():
            self.print(f'Closing file {file}', 2, 0)
            handle.close()

    def get_earliest_line(self):
        """
        loops through all the caches lines and returns the line with the earliest ts
        """

        files_sorted_by_ts = sorted(self.file_time, key=self.file_time.get)
        try:

            file_with_earliest_flow = files_sorted_by_ts[0]
        except IndexError:




            self.zeek_files = self.db.get_all_zeek_file()

            return False, False











        earliest_line = self.cache_lines[file_with_earliest_flow]
        return earliest_line, file_with_earliest_flow

    def read_zeek_files(self) -> int:

        self.zeek_files = self.db.get_all_zeek_file()
        self.open_file_handlers = {}
        self.file_time = {}
        self.cache_lines = {}

        self.last_updated_file_time = datetime.now()
        lines = 0
        while not self.should_stop():
            self.check_if_time_to_del_rotated_files()


            for filename in self.zeek_files:


                if not filename.endswith('.log'):
                    filename += '.log'

                if self.is_ignored_file(filename):
                    continue



                self.cache_nxt_line_in_file(filename)

            if self.should_stop_zeek():
                break

            earliest_line, file_with_earliest_flow = self.get_earliest_line()
            if not file_with_earliest_flow:
                continue

            self.print('	> Sent Line: {}'.format(earliest_line), 0, 3)
            self.profiler_queue.put(earliest_line)
            lines += 1

            if lines == 10 and self.testing:
                break

            del self.cache_lines[file_with_earliest_flow]
            del self.file_time[file_with_earliest_flow]


            self.zeek_files = self.db.get_all_zeek_file()

        self.close_all_handles()
        return lines

    def get_flows_number(self, file) -> int:
        """
        returns the number of flows/lines in a given file
        """




        def _make_gen(reader):
            """yeilds (64 kilobytes) at a time from the file"""
            while True:
                b = reader(2 ** 16)
                if not b: break
                yield b

        with open(file, "rb") as f:
            count = sum(buf.count(b"\n") for buf in _make_gen(f.raw.read))
        return count

    def read_zeek_folder(self):


        self.bro_timeout = 10
        if self.db.is_growing_zeek_dir():


            self.bro_timeout = float('inf')


        self.zeek_dir = self.given_path
        self.start_observer()



        if not hasattr(self, 'is_zeek_tabs'):
            full_path = os.path.join(self.given_path, os.listdir(self.given_path)[0])
            self.is_zeek_tabs = self.is_zeek_tabs_file(full_path)

        total_flows = 0
        for file in os.listdir(self.given_path):
            full_path = os.path.join(self.given_path, file)


            if self.is_ignored_file(full_path):
                continue

            if not self.db.is_growing_zeek_dir():

                total_flows += self.get_flows_number(full_path)
                if self.is_zeek_tabs:


                    total_flows -= 9


            filename, file_extension = os.path.splitext(file)
            if file_extension == '.log':

                self.db.add_zeek_file(
                    full_path[:-4]
                )




            if self.testing:
                break
        self.db.set_input_metadata({'total_flows': total_flows})

        lines = self.read_zeek_files()
        self.print(
            f'\nWe read everything from the folder.'
            f' No more input. Stopping input process. Sent {lines} lines', 2, 0,
        )

        return True

    def read_from_stdin(self):
        self.print('Receiving flows from stdin.')

        sys.stdin.close()
        sys.stdin = os.fdopen(0, 'r')
        file_stream = sys.stdin


        for line in file_stream:
            if line == '\n':
                continue


            if self.line_type == 'zeek':
                try:
                    line = json.loads(line)
                except json.decoder.JSONDecodeError:
                    self.print('Invalid json line')
                    continue

            line_info = {
                'type': 'stdin',
                'line_type': self.line_type,
                'data' : line
            }
            self.print(f'	> Sent Line: {line_info}', 0, 3)
            self.profiler_queue.put(line_info)
            self.lines += 1
            self.print('Done reading 1 flow.\n ', 0, 3)

        return True

    def handle_binetflow(self):

        total_flows = self.get_flows_number(self.given_path) -1
        self.db.set_input_metadata({'total_flows': total_flows})

        self.lines = 0
        with open(self.given_path) as file_stream:

            t_line = file_stream.readline()
            type_ = 'argus-tabs' if '\t' in t_line else 'argus'
            line = {
                'type': type_,
                'data': t_line
            }
            self.profiler_queue.put(line)
            self.lines += 1


            for t_line in file_stream:
                line = {
                    'type': type_,
                    'data': t_line
                }

                if len(t_line.strip()) != 0:
                    self.profiler_queue.put(line)

                self.lines += 1
                if self.testing: break
        return True

    def handle_suricata(self):
        total_flows = self.get_flows_number(self.given_path)
        self.db.set_input_metadata({'total_flows': total_flows})
        with open(self.given_path) as file_stream:
            for t_line in file_stream:
                line = {
                    'type': 'suricata',
                    'data': t_line,
                }
                self.print(f'	> Sent Line: {line}', 0, 3)
                if len(t_line.strip()) != 0:
                    self.profiler_queue.put(line)
                self.lines += 1
                if self.testing:
                    break
        return True

    def is_zeek_tabs_file(self, filepath) -> bool:
        """
        returns true if the given path is a zeek tab separated file
        :param filepath: full log file path with the .log extension
        """
        with open(filepath,'r') as f:
            line = f.readline()
            if '\t' in line:
                return True
            if line.startswith("#separator"):
                return True
            try:
                json.loads(line)
                return False
            except json.decoder.JSONDecodeError:
                return True

    def handle_zeek_log_file(self):
        """
        Handles conn.log files given to slips directly, and conn.log flows given to slips through CYST unix socket.
        """
        if (
                (not self.given_path.endswith(".log")
                or self.is_ignored_file(self.given_path))
                and 'cyst' not in self.given_path.lower()
        ):

            return False
        if os.path.exists(self.given_path):

            total_flows = self.get_flows_number(self.given_path)
            self.is_zeek_tabs = self.is_zeek_tabs_file(self.given_path)
            if self.is_zeek_tabs:


                total_flows -= 9
            self.db.set_input_metadata({'total_flows': total_flows})

        file_path_without_extension = os.path.splitext(self.given_path)[0]

        self.db.add_zeek_file(file_path_without_extension)





        self.bro_timeout = 30
        self.lines = self.read_zeek_files()
        return True

    def handle_nfdump(self):
        command = f'nfdump -b -N -o csv -q -r {self.given_path}'

        result = subprocess.run(command.split(), stdout=subprocess.PIPE)

        self.nfdump_output = result.stdout.decode('utf-8')
        self.lines = self.read_nfdump_output()
        self.print(
            f'We read everything. No more input. Stopping input process. Sent {self.lines} lines'
        )
        return True


    def start_observer(self):





        event_handler = FileEventHandler(
            self.zeek_dir,
            self.input_type,
            self.db
            )

        self.event_observer = Observer()

        self.event_observer.schedule(
            event_handler, self.zeek_dir, recursive=True
        )

        self.event_observer.schedule(
            event_handler, 'config/', recursive=True
        )

        self.event_observer.start()

    def handle_pcap_and_interface(self) -> int:
        """Returns the number of zeek lines read"""


        if not os.path.exists(self.zeek_dir):
            os.makedirs(self.zeek_dir)
        self.print(f'Storing zeek log files in {self.zeek_dir}')
        self.start_observer()

        if self.input_type == 'interface':

            self.bro_timeout = float('inf')
        elif self.input_type == 'pcap':


            self.bro_timeout = 30

        zeek_files = os.listdir(self.zeek_dir)
        if len(zeek_files) > 0:

            for f in zeek_files:
                os.remove(os.path.join(self.zeek_dir, f))


        self.zeek_thread.start()

        time.sleep(3)

        self.db.store_process_PID('Zeek', self.zeek_pid)
        if not hasattr(self, 'is_zeek_tabs'):
            self.is_zeek_tabs = False
        lines = self.read_zeek_files()
        self.print(
            f'We read everything. No more input. Stopping input process. Sent {lines} lines'
        )
        connlog_path = os.path.join(self.zeek_dir, 'conn.log')

        self.print(f"Number of zeek generated flows in conn.log: {self.get_flows_number(connlog_path)}", 2, 0)

        self.stop_observer()
        return True

    def stop_observer(self):

        try:
            self.event_observer.stop()
            self.event_observer.join()
        except AttributeError:

            pass

    def remove_old_zeek_files(self):
        """
        This thread waits for filemonitor.py to tell it that zeek changed the log files,
        it deletes old zeek-date.log files and clears slips' open handles and sleeps again
        """
        while not self.should_stop():

            if msg := self.get_msg('remove_old_files'):

                changed_files = json.loads(msg['data'])



                old_log_file = changed_files['old_file']
                new_log_file = changed_files['new_file']
                new_logfile_without_path = new_log_file.split('/')[-1].split(
                    '.'
                )[0]

                if new_logfile_without_path in self.ignored_files:

                    os.remove(old_log_file)
                    continue



                lock = threading.Lock()
                lock.acquire()
                try:

                    self.open_file_handlers[new_log_file].close()

                    del self.open_file_handlers[new_log_file]
                except KeyError:



                    pass

                self.to_be_deleted.append(old_log_file)
                self.time_rotated = float(utils.convert_format(datetime.now(), 'unixtimestamp'))

                lock.release()

    def shutdown_gracefully(self):
        self.stop_observer()
        self.stop_queues()
        try:
            self.remover_thread.join()
        except:
            pass
        try:
            self.zeek_thread.join()
        except:
            pass

        if hasattr(self, 'open_file_handlers'):
            self.close_all_handles()

        if hasattr(self, 'zeek_pid'):



            try:
                os.kill(self.zeek_pid, signal.SIGKILL)
            except Exception as e:
                pass
        return True

    def run_zeek(self):
        """
        This thread sets the correct zeek parameters and starts zeek
        """
        def detach_child():
            """
            Detach zeek from the parent process group(inputprocess), the child(zeek)
             will no longer receive signals
            """


            os.setpgrp()


        rotation = []
        if self.input_type == 'interface':
            if self.enable_rotation:

                rotation = ['-e', f"redef Log::default_rotation_interval = {self.rotation_period} ;"]
            bro_parameter = ['-i', self.given_path]

        elif self.input_type == 'pcap':

            given_path = self.given_path
            if not os.path.isabs(self.given_path):






                given_path = os.path.join(os.getcwd(), self.given_path)



            bro_parameter = ['-r', given_path]



        zeek_scripts_dir = os.path.join(os.getcwd(), 'zeek-scripts')
        packet_filter = ['-f ', self.packet_filter] if self.packet_filter else []






        command = [self.zeek_or_bro, '-C']
        command += bro_parameter
        command += [
            f'tcp_inactivity_timeout={self.tcp_inactivity_timeout}mins',
            'tcp_attempt_delay=1min',
            zeek_scripts_dir
        ]
        command += rotation
        command += packet_filter


        self.print(f'Zeek command: {" ".join(command)}', 3, 0)

        zeek = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            cwd=self.zeek_dir,
            preexec_fn=detach_child,
        )

        self.zeek_pid = zeek.pid

        out, error = zeek.communicate()
        if out:
            print(f"Zeek: {out}")
        if error:
            self.print(f"Zeek error. return code: {zeek.returncode} error:{error.strip()}")

    def handle_cyst(self):
        """
        Read flows sent by any external module (for example the cYST module)
        Supported flows are of type zeek conn log
        """



        if self.line_type != 'zeek':
            return

        channel = self.db.subscribe('new_module_flow')
        self.channels.update({'new_module_flow': channel})
        while not self.should_stop():



            msg = self.get_msg('new_module_flow')
            if msg and msg['data'] == 'stop_process':
                self.shutdown_gracefully()
                return True

            if msg := self.get_msg('new_module_flow'):
                msg: str = msg["data"]
                msg = json.loads(msg)
                flow = msg['flow']
                src_module = msg['module']
                line_info = {
                    'type': 'external_module',
                    'module': src_module,
                    'line_type': self.line_type,
                    'data': flow
                }
                self.print(f'   > Sent Line: {line_info}', 0, 3)
                self.profiler_queue.put(line_info)
                self.lines += 1
                self.print('Done reading 1 CYST flow.\n ', 0, 3)

                time.sleep(2)



    def main(self):
        utils.drop_root_privs()
        if (
            '-i' in sys.argv
            or self.db.is_growing_zeek_dir()
        ):




            self.remover_thread.start()





        if self.input_type == 'stdin':
            self.read_from_stdin()
        elif self.input_type == 'zeek_folder':

            self.read_zeek_folder()
        elif self.input_type == 'zeek_log_file':

            file_name = self.given_path.split('/')[-1]
            if 'log' in file_name:
                self.handle_zeek_log_file()
            else:
                return False
        elif self.input_type == 'nfdump':

            self.handle_nfdump()
        elif self.input_type == 'binetflow' or 'binetflow-tabs' in self.input_type:

            self.handle_binetflow()
        elif self.input_type in ['pcap', 'interface']:
            self.handle_pcap_and_interface()
        elif self.input_type == 'suricata':
            self.handle_suricata()
        elif self.input_type == 'CYST':
            self.handle_cyst()
        else:


            self.print(
                f'Unrecognized file type "{self.input_type}". Stopping.'
            )
            return False

